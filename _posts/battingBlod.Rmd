---
title: "Batting"
author: "ThomasOlsen"
date: "2023-10-12"
output: html_document
---
# Introduction
This guide will demonstrate how to download and explore batting data using an R-Shiny App.

### Downloading the Data
To download the data navigate to www.baseball-reference.com and hover over the seasons tab. In the drop down
menu click on batting.  This will send you to a table that will have batting data from the 2023 season.  Scroll down to Player Standard Bating and click on Share & Export.  Choose your prefferred file type and download the data

### Creating an R-Shiny Application
To create an R-Shiny application, in R-Studio click File > New File > Shiny Web App
In the pop up card, name your application and click the multiple files button.

### Layout
R-shiny gives us a sample app to start. Clear out the data inside of the functions so that the app will still run, but is blank.  It should look something like this:

```{r}
library(shiny)

ui <- fluidPage(
  
)

server <- function(input, output, session) {
  
}

shinyApp(ui, server)

```

Now lets read in the data


### Reading in the data
Reading in the data may require some troubleshooting.  The excel workbook is a .xls file so to read in the data it may be necessary to open the data and copy it into a .xlsx file or a csv file.  Once the data is in a readable file read in the data using read_xlsx or read_csv.

The readxl package is required to download .xlsx data
Since we are going to use our batting data in different places of our data read in the battingData at the top of the R-Shiny app.
```{r warning=FALSE , echo=TRUE, message=FALSE}
library(tidyverse)
library(readxl)
battingData = read_xlsx("battingData.xlsx")

library(shiny)

ui <- fluidPage(
  
)

server <- function(input, output, session) {
  
}

#shinyApp(ui, server)
```

## Adding Elements

Visit the R-Shiny website for complete documentation, but R-Shiny works by using two files that work hand in glove.  The server part of the app is in charge of rendering the app data and the ui part is in charge of outputting the visuals the app.

To help us with rendering datatable we will use the DT package
Install the package using the following code :

```{r echo=TRUE}
#install.packages("DT")

```

Now we are ready to display our first datatable. The two functions we will need are dataTableOutput() and renderDataTable(). In the server function we use the renderDataTable and save it to the variable output$table.  The id of the datatable we made is 'table' so we pass 'table' to the dataTableOutput function to be displayed.  The code will now run and display our datatable!
```{r warning=FALSE}

library(tidyverse)
library(readxl)
library(DT)
battingData = read_xlsx("battingData.xlsx")

library(shiny)

ui <- fluidPage(
    dataTableOutput("table") 
)

server <- function(input, output, session) {
  
  output$table = renderDataTable({
    
      battingData
    
  })
  
}

shinyApp(ui, server)

```
## Creating Plot in ui.R

Creating a plot is similar in R-Shiny.  First we will make our plot in server.R using the renderPlot function. Now create your graph using whichever plotting functions you like. Save your graph to an output object in the code below I saved mine as 'plot'.  Now in ui.r add the plotOutput function below your dataTableOutput function and put in the id of your plot.

```{r}
library(tidyverse)
library(readxl)
library(DT)
battingData = read_xlsx("battingData.xlsx")

library(shiny)

ui <- fluidPage(
    dataTableOutput("table"), 
    plotOutput("plot")
)

server <- function(input, output, session) {
  
  output$table = renderDataTable({
    
      battingData
    
  })
  
  output$plot = renderPlot({
    
    battingData %>% ggplot(mapping = aes(x = BB, y = HR)) +
      geom_point() +
      theme_bw() 
    
  })
  
}

shinyApp(ui, server)


```

## Buttons

To add interactivity we first need to add check boxes and radio buttons to ui.R  Checkboxes allow for multiple boxes to be selected so we will use them to filter to the columns we want see. We can also specify what columns are pre-selected when the app is loaded.
We can also add radio buttons to choose our x and y axis for our scatter plot. **The order that the functions are placed in the ui.R is the order they will appear in the app so place them intentionally!**
```{r warning=FALSE, message=FALSE}

library(tidyverse)
library(readxl)
library(DT)
battingData = read_xlsx("battingData.xlsx")

library(shiny)

ui <- fluidPage(
  
    fluidRow(checkboxGroupInput("stats", inline = T, label = "Stats", choices = c("Name", "BA", "SLG", "OPS", "SO", "HR", "OBP", "BB"), selected = c("Name", "BA", "SLG", "OPS"))),
    dataTableOutput("table"), 
    radioButtons("x", inline = T, label = "X-Axis", choices = c("OBP","HR", "BA", "BB", "SO")),
    radioButtons("y", inline = T, label = "Y-Axis", choices = c("OBP","HR", "BA", "BB", "SO")),
    plotOutput("plot")
)

server <- function(input, output, session) {
  
  output$table = renderDataTable({
    
      battingData
    
  })
  
  output$plot = renderPlot({
    
    battingData %>% ggplot(mapping = aes(x = BB, y = HR)) +
      geom_point() +
      theme_bw() 
    
  })
  
}

shinyApp(ui, server)

```
## Interactivity

Finally it is time to make our plots and tables interactive. To do so we will into the server.R function. To select only the columns that we checked we will use the select function from dplyr and put in *input\\$stats* . *Input\\$stats* is the reverse of *output\\$id* now instead of passing an ID to the output function we are passing an ID to the render function.


```{r}


library(tidyverse)
library(readxl)
library(DT)
battingData = read_xlsx("battingData.xlsx")

library(shiny)

ui <- fluidPage(
  
    fluidRow(checkboxGroupInput("stats", inline = T, label = "Stats", choices = c("Name", "BA", "SLG", "OPS", "SO", "HR", "OBP", "BB"), selected = c("Name", "BA", "SLG", "OPS"))),
    dataTableOutput("table"), 
    radioButtons("x", inline = T, label = "X-Axis", choices = c("OBP","HR", "BA", "BB", "SO")),
    radioButtons("y", inline = T, label = "Y-Axis", choices = c("OBP","HR", "BA", "BB", "SO")),
    plotOutput("plot")
)

server <- function(input, output, session) {
  
  output$table = renderDataTable({
    
      battingData %>% select(input$stats)
    
  })
  
  output$plot = renderPlot({
    
    battingData %>% ggplot(mapping = aes_string(x = input$x, y = input$y)) +  #aes_string is neccessary to make sure that R interprets the interactive element as a column not a character
      geom_point() +
      theme_bw() 
    
  })
  
}

shinyApp(ui, server)


```


## Conclusion

Congrats! You have made your first interactive R-Shiny app.  R-Shiny is truly canvas and the possibilities are endless. Checkout the documentation at 
https://shiny.posit.co/ to learn how to further customize your R-Shiny app!

